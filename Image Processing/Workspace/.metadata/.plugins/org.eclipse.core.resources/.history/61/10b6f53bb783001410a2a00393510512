package common;

/*
 * Add OpenCV:
 * http://docs.opencv.org/doc/tutorials/introduction/java_eclipse/java_eclipse.html#java-eclipse
 */

import java.io.File;
import java.io.IOException;
import java.util.Arrays;

import org.opencv.core.*;
import org.opencv.core.Core.MinMaxLocResult;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class Main 
{
	private static final int RANGE_UNDER = 25;
	private static final int RANGE_OVER  = 25;
	private static int gCount = 0;
	
	public static void main(String[] args) throws IOException 
	{
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
		Point[]  locations;
		Mat[]    images;
		
		String searchString = "lena";
		Imshow window       = new Imshow("search");
		Mat    search       = Imgcodecs.imread("test/search0.png");
		
		File folder = new File("images/" + searchString);
		
		if(!folder.exists())
		{
			System.out.println("Folder doesnt exist.");
			return;
		}
		
		if(folder.listFiles().length <= 0)
		{
			System.out.println("No files in folder.");
			return;
		}
		
		locations = new Point[folder.listFiles().length];
		
		for(int i = 0; i < folder.listFiles().length; i++)
		{
			System.out.println(folder.listFiles()[i].getPath());
			Mat image = Imgcodecs.imread(folder.listFiles()[i].getPath());

			//Logpolar -> Normalize for scale/rotation
			Mat logPolarSearch = new Mat(search.rows(), search.cols(), CvType.CV_32FC1);
			Mat logPolarImage = new Mat(image.rows(), image.cols(), CvType.CV_32FC1);
			Imgproc.logPolar(search, logPolarSearch, 
					         new Point(logPolarSearch.cols() / 2, logPolarSearch.rows() / 2), 
					         1, Imgproc.CV_WARP_INVERSE_MAP);
			
			Imgproc.logPolar(image, logPolarImage, 
			         new Point(logPolarImage.cols() / 2, logPolarImage.rows() / 2), 
			         1, Imgproc.CV_WARP_INVERSE_MAP);
			
			locations[i] = imageSearch(logPolarSearch, logPolarImage);
			
			if(locations[i] != null)
			{
				Imgproc.rectangle(search, locations[i], new Point(locations[i].x + image.cols(), 
					          	locations[i].y + image.rows()), new Scalar(0, 255 / (i+1), 0));
			}
		}
		
		
		for (int i = 0; i < locations.length; i++) 
		{
			System.out.println(locations[i]);
		}
		
		for (int i = 0; i < locations.length; i++) 
		{
			System.out.println(locations[i]);
		}
		
		// search lena
		window.showImage(search);
		
		// search elephant		
		//Mat    search1 = Highgui.imread("test/search1.jpg");
		//window.showImage(search);
		
		// search elephant		
		//Mat    search2 = Highgui.imread("test/search2.jpg");
		//window.showImage(search);
		
		// search lion		
		//Mat    search3 = Highgui.imread("test/search3.jpg");
		//window.showImage(search);
		
		// close all...
		System.in.read();
		System.exit(0);
	}
	
	private static Point imageSearch(Mat source, Mat template)
	{
		//TODO source greater than template -> resize?
		if(source.cols() < template.cols())
		{
			//resize
		}
		
		if(source.rows() < template.rows())
		{
			//resize
		}
		
		int             cols           = source.cols() - template.cols() + 1;
		int             rows           = source.rows() - template.rows() + 1;
		Mat             result         = new Mat(cols, rows, CvType.CV_32FC1);
		Point           location       = null;
		MinMaxLocResult minMaxLocation = null;
		
		// matching, normalize
		Imgproc.matchTemplate(source, template, result, Imgproc.TM_CCOEFF);
		Core.normalize(result, result, 0, 1, Core.NORM_MINMAX, -1, new Mat());
		Imgproc.threshold(result, result, 0.9, 1, 2);
		
		// find best match
		minMaxLocation = Core.minMaxLoc(result);
		
		// method = Imgproc.TM_SQDIFF || Imgproc.TM_SQDIFF_NORMED
		// location = minMaxLocation.minLoc;
		// else
		location = minMaxLocation.maxLoc;

		// TODO Border Y-Axis?
		if(location.y <= 0.1)
		{
			return null;
		}
		
		return location;
	}
}