package common;

import org.opencv.core.*;
import org.opencv.core.Core.MinMaxLocResult;
import org.opencv.imgcodecs.*;
import org.opencv.imgproc.*;

public class Test 
{
	public static void main(String[] args) 
	{
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
		
		// open images
		Mat src      = Imgcodecs.imread("test/search0.png", Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);
		Mat tpl      = Imgcodecs.imread("images/lena/lena0.png", Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);
		
		//Imshow.show(src);
		//Imshow.show(tpl);
		
		// generate log polar images
		Mat srcPolar = new Mat(src.rows(), src.cols(), src.type());
		Mat tplPolar = new Mat(tpl.rows(), tpl.cols(), tpl.type());
		Mat srcCart  = new Mat(src.rows(), src.cols(), src.type());
		Mat tplCart  = new Mat(tpl.rows(), tpl.cols(), tpl.type());
		
		Imgproc.logPolar(src, srcPolar, new Point(src.cols() * .5, src.rows() * .5), 
                30, Imgproc.INTER_LINEAR + Imgproc.CV_WARP_FILL_OUTLIERS);
		Imgproc.logPolar(tpl, tplPolar, new Point(tpl.cols() * .5, tpl.rows() * .5), 
				30, Imgproc.INTER_LINEAR + Imgproc.CV_WARP_FILL_OUTLIERS);
		
		Imgproc.logPolar(srcPolar, srcCart, new Point(src.cols() * .5, src.rows() * .5), 
				30, Imgproc.INTER_LINEAR + Imgproc.CV_WARP_INVERSE_MAP);
		Imgproc.logPolar(tplPolar, tplCart, new Point(tpl.cols() * .5, tpl.rows() * .5), 
				30, Imgproc.INTER_LINEAR + Imgproc.CV_WARP_INVERSE_MAP);
		
		//Imshow.show(srcPolar);
		//Imshow.show(tplPolar);
		//Imshow.show(srcCart);
		//Imshow.show(tplCart);
		
		// check for template matching
		Mat matchResult = new Mat();
		Mat matchResultCart = new Mat();
		Imgproc.matchTemplate(srcPolar, tplPolar, matchResult, Imgproc.TM_CCOEFF);
		//Core.normalize(matchResult, matchResult, 0, 1, Core.NORM_MINMAX, -1, new Mat());
		
		Imgproc.logPolar(matchResult, matchResultCart, new Point(matchResult.cols() * .5, matchResult.rows() * .5), 
				30, Imgproc.INTER_LINEAR + Imgproc.CV_WARP_INVERSE_MAP);
		Core.normalize(matchResult, matchResult, 0, 1, Core.NORM_MINMAX, -1, new Mat());
		
		//generate binary view
		/*
		Mat threshold = new Mat();
		Mat thresholdShow = new Mat();
		Imgproc.threshold(matchResult, threshold, 0.5, 255, 0);
		threshold.convertTo(thresholdShow, src.type());
		
		//System.out.println(thresholdShow);
		//Imshow.show(thresholdShow);
		
		// classify and rate the result
		MinMaxLocResult minMaxLocation = Core.minMaxLoc(matchResult);
		Point location = minMaxLocation.maxLoc;
		
		System.out.println(minMaxLocation.maxLoc);
		Imgproc.rectangle(thresholdShow, location, new Point(location.x + tpl.cols(), 
			      location.y + tpl.rows()), new Scalar(0, 255, 0));
		Imshow.show(thresholdShow);*/
	}
}